<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lootfiend Build Synergy Explorer</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@500;700&family=Source+Sans+Pro:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="lootfiend-styles.css">
</head>
<body>
  <header>
    <h1>LOOTFIEND</h1>
    <p class="subtitle">BUILD SYNERGY EXPLORER</p>
  </header>

  <div class="tab-nav">
    <button class="tab-btn active" data-tab="current">MY BUILD</button>
    <button class="tab-btn" data-tab="theorycraft">THEORYCRAFT</button>
    <button class="tab-btn" data-tab="profile">PROFILE</button>
    <button class="tab-btn" data-tab="data">DATA</button>
  </div>

  <div class="tab-content active" id="tab-current">
    <div class="builder-layout">
      <div class="builder-main" id="current-builder"></div>
      <div class="analysis-panel" id="current-analysis"></div>
    </div>
  </div>

  <div class="tab-content" id="tab-theorycraft">
    <div class="theorycraft-layout">
      <div class="current-build-sidebar" id="current-sidebar"></div>
      <div class="builder-main" id="theory-builder"></div>
      <div class="analysis-panel" id="theory-analysis"></div>
    </div>
  </div>

  <div class="tab-content" id="tab-profile">
    <div class="profile-container">
      <div class="profile-section">
        <div class="profile-section-title">‚≠ê ZENITH POINTS <span class="save-indicator" id="zenith-saved">‚úì Saved</span></div>
        <div class="zenith-pool">
          <span class="zenith-pool-label">Total Pool:</span>
          <input type="number" class="zenith-pool-input" id="zenith-pool" value="140" onchange="updateZenithPool(this.value)">
          <span class="zenith-remaining" id="zenith-remaining">140 remaining</span>
        </div>
        <div class="zenith-grid" id="zenith-inputs"></div>
      </div>
      <div class="profile-section">
        <div class="profile-section-title">üìä CHARACTER STATS <span class="save-indicator" id="stats-saved">‚úì Saved</span></div>
        <div class="stats-grid" id="stats-inputs"></div>
        <div class="profile-actions" style="margin-top: 12px;">
          <button class="profile-btn secondary" onclick="loadStatsFromSheet()">Load from Sheet</button>
        </div>
      </div>
      <div class="profile-section">
        <div class="profile-section-title">üîÆ RUNE UNLOCKS <span class="save-indicator" id="runes-saved">‚úì Saved</span></div>
        <p style="font-size: 10px; color: rgba(200,200,210,0.4); margin-bottom: 12px;">Click tier to set your highest unlock.</p>
        <div id="rune-unlocks"></div>
      </div>
      <div class="profile-actions">
        <button class="profile-btn secondary" onclick="resetProfile()">Reset All</button>
      </div>
    </div>
  </div>

  <div class="tab-content" id="tab-data">
    <div class="config-panel">
      <div class="config-title">üìÅ GOOGLE SHEETS</div>
      <div class="config-row">
        <div class="config-label">SHEET ID</div>
        <input type="text" class="config-input" id="sheet-id" placeholder="From URL">
        <div class="config-help">docs.google.com/spreadsheets/d/<strong>THIS</strong>/edit</div>
      </div>
      <button class="config-button" onclick="loadFromSheets()">Load Data</button>
      <div class="config-status" id="config-status"></div>
    </div>
  </div>

  <script>
    // ============ DATA ============
    let SKILLS = {
      basic: [
        { id: 'frost_projectile', name: 'Frost Projectile', element: 'Ice', atk: 60, status: 'Chill', desc: '60% ATK, Chill', hitRate: 'medium', provides: ['ice', 'chill'] },
        { id: 'flame_wave', name: 'Flame Wave', element: 'Fire', atk: 30, status: 'Burning', desc: '30% ATK, Burning', hitRate: 'medium', provides: ['fire', 'burning'] },
        { id: 'lightning_whip', name: 'Lightning Whip', element: 'Lightning', atk: 50, status: 'Shock', desc: '50% ATK, Shock', hitRate: 'medium', provides: ['lightning', 'shock'] },
      ],
      core: [
        { id: 'fireball', name: 'Fireball', element: 'Fire', atk: 70, status: 'Burning', mpCost: 20, desc: '70% ATK, Burning', hitRate: 'low', provides: ['fire', 'burning', 'burst'] },
        { id: 'lightning_punch', name: 'Lightning Punch', element: 'Lightning', atk: 160, status: 'Shock', mpCost: 30, desc: '160% ATK, Shock', hitRate: 'low', provides: ['lightning', 'shock', 'burst'] },
        { id: 'ice_ray', name: 'Ice Ray', element: 'Ice', atk: 70, status: 'Chill', mpCost: 40, desc: '70% ATK channel, Chill', hitRate: 'high', provides: ['ice', 'chill', 'multi-hit', 'channel'] },
      ],
      basicControl: [
        { id: 'concussion', name: 'Concussion', element: null, atk: 50, cd: 12, desc: 'Knockback + stun', provides: ['control', 'stun'] },
        { id: 'flash', name: 'Flash', element: null, atk: 0, cd: 12, hpRecovery: 15, desc: 'Dodge, 15% HP', provides: ['sustain', 'mobility'] },
        { id: 'gravity_field', name: 'Gravity Field', element: null, atk: 0, cd: 20, desc: 'Slow zone', provides: ['control', 'aoe'] },
      ],
      elemControl: [
        { id: 'lightning_orb', name: 'Lightning Orb', element: 'Lightning', atk: 35, status: 'Shock', cd: 12, desc: 'Shock orb', provides: ['lightning', 'shock'] },
        { id: 'frost_shield', name: 'Frost Shield', element: 'Ice', atk: 0, cd: 15, shield: 35, desc: '35% HP shield', provides: ['ice', 'shield', 'sustain'] },
        { id: 'infernal_bloom', name: 'Infernal Bloom', element: 'Fire', atk: 0, cd: 12, desc: 'Fire turret', provides: ['fire', 'summon'] },
      ],
      ultimate: [
        { id: 'hail', name: 'Hail', element: 'Ice', atk: 50, status: 'Chill', cd: 20, desc: 'Ice storm', hitRate: 'high', provides: ['ice', 'chill', 'multi-hit', 'aoe'] },
        { id: 'doppelganger', name: 'Doppelganger', element: null, atk: 0, cd: 35, desc: 'Clone', provides: ['clone'] },
        { id: 'aether_form', name: 'Aether Form', element: null, atk: 0, cd: 40, desc: 'Transform', provides: [] },
      ],
    };

    let PASSIVES = [
      { id: 'elemental_resonance', name: 'Elemental Resonance', desc: '+5% per status', archetype: 'status', provides: [], wants: ['status-variety'] },
      { id: 'life_rewind', name: 'Life Rewind', desc: '100% HP at 30%', archetype: 'sustain', provides: ['sustain'], wants: [] },
      { id: 'energy_affinity', name: 'Energy Affinity', desc: '+10% MP Regen', archetype: 'utility', provides: ['mp'], wants: [] },
      { id: 'tumbler', name: 'Tumbler', desc: '+25% Evasion', archetype: 'sustain', provides: ['sustain', 'evasion'], wants: [] },
      { id: 'flourish', name: 'Flourish', desc: '+15% Dmg >80% HP', archetype: 'sustain', conditionalDmg: true, provides: ['dmg-boost'], wants: ['sustain'] },
      { id: 'soul_hunt', name: 'Soul Hunt', desc: '+2 MP/HP on kill', archetype: 'sustain', provides: ['sustain', 'mp'], wants: [] },
      { id: 'demon_pact', name: 'Demon Pact', desc: '+30% Dmg, +30% taken', downside: true, archetype: 'burst', provides: ['dmg-boost'], wants: [] },
      { id: 'arcane_shield', name: 'Arcane Shield', desc: 'Shield after 3s', archetype: 'sustain', provides: ['shield', 'sustain'], wants: [] },
      { id: 'conjuration', name: 'Conjuration', desc: '-10% cooldowns', archetype: 'utility', provides: ['cd-reduction'], wants: [] },
    ];

    let RUNES = [
      // Basic Skills
      { skill: 'Frost Projectile', name: 'Ice Armor', blueEffect: 'Final Dmg‚Üì +5%', purpleEffect: '+2.5% Final Dmg‚Üì per stack', orange1Effect: 'HoH +30%', orange2Effect: '4% per stack (8 max)', newElement: null, addsStatus: null, keyStats: 'Final Dmg‚Üì +5%, HoH +30%', provides: ['ice', 'hoh', 'sustain', 'final-dmg-down'], wants: [] },
      { skill: 'Frost Projectile', name: 'Icicle', blueEffect: 'Haste +10%', purpleEffect: '20% Imprison on Chill 1.5s', orange1Effect: 'Dmg +30%', orange2Effect: 'Ice spikes 5x50% ATK', newElement: null, addsStatus: 'Imprison', keyStats: 'Haste +10%, Dmg +30%', provides: ['ice', 'imprison', 'haste', 'dmg-boost', 'control'], wants: ['chill'] },
      { skill: 'Flame Wave', name: 'Scorch', blueEffect: '+2 Mana on use', purpleEffect: '+2.5% Ele Dmg per stack', orange1Effect: 'Haste +10%', orange2Effect: '4% per stack (12 max)', newElement: null, addsStatus: null, keyStats: 'Ele Dmg stacking, Haste +10%', provides: ['fire', 'ele-dmg', 'haste', 'mp'], wants: [] },
      { skill: 'Flame Wave', name: 'Explosion', blueEffect: 'Dmg +30%', purpleEffect: 'Applies 2 Vulnerable stacks', orange1Effect: 'DoT +20%', orange2Effect: '30% chance explode 180% ATK + 3 Vulnerable', newElement: null, addsStatus: 'Vulnerable', keyStats: 'Dmg +30%, DoT +20%', provides: ['fire', 'vulnerable', 'dmg-boost', 'dot-boost', 'clone-synergy'], wants: ['burning'] },
      { skill: 'Lightning Whip', name: 'Numb', blueEffect: 'Crit Chance +10%', purpleEffect: '+20% Crit vs Shocked', orange1Effect: 'Crit Chance +5%', orange2Effect: '20% stun on crit 0.5s', newElement: null, addsStatus: 'Stun', keyStats: 'Crit Chance +15%', provides: ['lightning', 'crit-chance', 'stun'], wants: ['shock'] },
      { skill: 'Lightning Whip', name: 'Energize', blueEffect: 'Ele Dmg +5%', purpleEffect: '30% chance +3 MP on Electrocuted', orange1Effect: 'MP Regen +5%', orange2Effect: '+5 MP instead', newElement: null, addsStatus: null, keyStats: 'Ele Dmg +5%, MP Regen +5%', provides: ['lightning', 'ele-dmg', 'mp'], wants: ['electrocution'] },
      // Core Skills
      { skill: 'Fireball', name: 'Pyroblast', blueEffect: 'Crit Chance +5%', purpleEffect: 'Lava fireball 120% ATK 3 Burning', orange1Effect: 'Crit Dmg +45%', orange2Effect: '50% chance lava bomb 200% ATK', newElement: null, addsStatus: null, keyStats: 'Crit Chance +5%, Crit Dmg +45%', provides: ['fire', 'crit-chance', 'crit-dmg', 'burning-stacks', 'burst'], wants: [] },
      { skill: 'Fireball', name: 'Jolt', blueEffect: 'Dmg +30%', purpleEffect: 'Lightning spear 200% ATK 2 Electrocution', orange1Effect: 'Crit Chance +10%', orange2Effect: '25% Thunder Gods Spear 500% ATK', newElement: 'Lightning', addsStatus: 'Electrocution', keyStats: 'Dmg +30%, Crit Chance +10%', provides: ['lightning', 'electrocution', 'crit-chance', 'dmg-boost', 'burst'], wants: [] },
      { skill: 'Fireball', name: 'Iceflame', blueEffect: 'HoH +30%', purpleEffect: '5 ice shards + Chill + Burning', orange1Effect: 'Additional Damage +30%', orange2Effect: 'Ice Crystal stacks ‚Üí Flower', newElement: 'Ice', addsStatus: 'Chill, Burning', keyStats: 'HoH +30%, Add Dmg +30%', provides: ['ice', 'chill', 'burning', 'hoh', 'add-dmg', 'multi-hit'], wants: [] },
      { skill: 'Lightning Punch', name: 'Ice Sword', blueEffect: 'Dmg +30%', purpleEffect: 'Frost sword 500% ATK + Chill', orange1Effect: 'Final Dmg +5%', orange2Effect: 'On crit freeze 0.5s', newElement: 'Ice', addsStatus: 'Chill, Freeze', keyStats: 'Dmg +30%, Final Dmg +5%', provides: ['ice', 'chill', 'freeze', 'dmg-boost', 'final-dmg', 'burst', 'control'], wants: ['crit-chance'] },
      { skill: 'Lightning Punch', name: 'Flame Bow', blueEffect: 'DoT +20%', purpleEffect: 'Flame arrow 200% ATK 3 Burning', orange1Effect: 'Crit Chance +10%', orange2Effect: '30% fire dragon 350% ATK + 20 Burning', newElement: 'Fire', addsStatus: 'Burning', keyStats: 'DoT +20%, Crit Chance +10%', provides: ['fire', 'burning-stacks', 'dot-boost', 'crit-chance'], wants: [] },
      { skill: 'Lightning Punch', name: 'Thunder Punch', blueEffect: 'Crit Chance +5%', purpleEffect: '300% ATK 3 Electrocution', orange1Effect: 'Add Dmg Chance +15%', orange2Effect: '30% continuous blast 200% ATK', newElement: null, addsStatus: 'Electrocution', keyStats: 'Crit Chance +5%, Add Dmg +15%', provides: ['lightning', 'electrocution', 'crit-chance', 'add-dmg'], wants: [] },
      { skill: 'Ice Ray', name: 'Rimebite', blueEffect: 'Add Dmg +45%', purpleEffect: 'Interval reduced to 0.3s', orange1Effect: 'Add Dmg Chance +10%', orange2Effect: 'Each hit +1 Frostbite', newElement: null, addsStatus: 'Frostbite', keyStats: 'Add Dmg +45%, Add Dmg Chance +10%', provides: ['ice', 'multi-hit', 'add-dmg', 'frostbite'], wants: ['hoh'] },
      { skill: 'Ice Ray', name: 'Pyresight', blueEffect: 'DoT +20%', purpleEffect: 'Hellish Eye sweep 300% ATK 3 Burning', orange1Effect: 'MP Cost -8', orange2Effect: 'Leaves burning area', newElement: 'Fire', addsStatus: 'Burning', keyStats: 'DoT +20%, MP Cost -8', provides: ['fire', 'burning-stacks', 'dot-boost', 'aoe'], wants: [] },
      { skill: 'Ice Ray', name: 'Ionization', blueEffect: 'Dmg +30%', purpleEffect: 'EM beam 100% ATK/tick + Shock', orange1Effect: 'Add Dmg Chance +15%', orange2Effect: '+5% Energy Charge on hit', newElement: 'Lightning', addsStatus: 'Shock', keyStats: 'Dmg +30%, Add Dmg Chance +15%', provides: ['lightning', 'shock', 'multi-hit', 'dmg-boost', 'add-dmg'], wants: [] },
      // Basic Control Skills
      { skill: 'Concussion', name: 'Imprison', blueEffect: 'Final Dmg +5%', purpleEffect: 'Increased range + 5 Vulnerable', orange1Effect: 'Crit Chance +5%', orange2Effect: '10 Vulnerable + 90% slow', newElement: null, addsStatus: 'Vulnerable', keyStats: 'Final Dmg +5%, Crit Chance +5%', provides: ['vulnerable', 'final-dmg', 'crit-chance', 'control'], wants: [] },
      { skill: 'Concussion', name: 'Echo', blueEffect: 'CD -2s', purpleEffect: 'Recovers 15 MP on hit', orange1Effect: 'MP Regen +5%', orange2Effect: 'Knocks back 2 more times', newElement: null, addsStatus: null, keyStats: 'CD -2s, MP Regen +5%', provides: ['cd-reduction', 'mp', 'control'], wants: [] },
      { skill: 'Flash', name: 'Backstab', blueEffect: 'MP Regen +5%', purpleEffect: 'Teleport behind + Robust 3s', orange1Effect: 'Healing +20%', orange2Effect: 'Auto-casts again after 3s', newElement: null, addsStatus: 'Robust', keyStats: 'MP Regen +5%, Healing +20%', provides: ['mp', 'sustain', 'heal-boost'], wants: [] },
      { skill: 'Flash', name: 'Stunt', blueEffect: 'CD -2s', purpleEffect: 'Leaves decoy 30% HP 5s', orange1Effect: 'HoH +30%', orange2Effect: 'Double HP recovered', newElement: null, addsStatus: null, keyStats: 'CD -2s, HoH +30%', provides: ['cd-reduction', 'hoh', 'sustain'], wants: [] },
      { skill: 'Gravity Field', name: 'Black Hole', blueEffect: 'Final Dmg +5%', purpleEffect: '10% ATK/s + pulls to center', orange1Effect: 'Skill Dmg +100%', orange2Effect: '20% ATK + 2 Vulnerable', newElement: null, addsStatus: 'Vulnerable', keyStats: 'Final Dmg +5%, Skill Dmg +100%', provides: ['vulnerable', 'final-dmg', 'aoe', 'control'], wants: [] },
      { skill: 'Gravity Field', name: 'Domain', blueEffect: 'Final Dmg‚Üì +5%', purpleEffect: 'Centers on character, 2x range', orange1Effect: 'Evasion +5%', orange2Effect: '+20% Haste for allies', newElement: null, addsStatus: null, keyStats: 'Final Dmg‚Üì +5%, Evasion +5%', provides: ['final-dmg-down', 'evasion', 'haste', 'sustain'], wants: [] },
      // Elemental Control Skills
      { skill: 'Lightning Orb', name: 'Electrolysis', blueEffect: 'Dmg +30%', purpleEffect: 'Large orb 200% ATK 3 Electrocution', orange1Effect: 'Crit Chance +5%', orange2Effect: '250% ATK 5 Electrocution 1s Stun', newElement: null, addsStatus: 'Electrocution', keyStats: 'Dmg +30%, Crit Chance +5%', provides: ['lightning', 'electrocution', 'stun', 'dmg-boost', 'crit-chance', 'burst'], wants: [] },
      { skill: 'Lightning Orb', name: 'Frozen', blueEffect: 'CD -2s', purpleEffect: 'Rotating ice orb 150% ATK/0.5s', orange1Effect: 'Final Dmg‚Üì +5%', orange2Effect: '250% ATK + 1.5s Imprison', newElement: 'Ice', addsStatus: 'Imprison', keyStats: 'CD -2s, Final Dmg‚Üì +5%', provides: ['ice', 'imprison', 'cd-reduction', 'final-dmg-down', 'multi-hit', 'control'], wants: [] },
      { skill: 'Frost Shield', name: 'Shattered Ice', blueEffect: 'Shield +10%', purpleEffect: 'Applies to all allies', orange1Effect: 'Final Dmg‚Üì +5%', orange2Effect: 'Freezes enemies 1s on end', newElement: null, addsStatus: 'Freeze', keyStats: 'Shield +10%, Final Dmg‚Üì +5%', provides: ['ice', 'shield', 'sustain', 'freeze', 'final-dmg-down', 'control'], wants: [] },
      { skill: 'Frost Shield', name: 'Molten Fire', blueEffect: 'CD -3s', purpleEffect: '50% ATK/s + 1 Burning + Robust', orange1Effect: 'Ele Dmg +5%', orange2Effect: '8s duration +15% Ele Dmg', newElement: 'Fire', addsStatus: 'Burning', keyStats: 'CD -3s, Ele Dmg +20%', provides: ['fire', 'burning', 'ele-dmg', 'cd-reduction'], wants: [] },
      { skill: 'Infernal Bloom', name: 'Fire Core', blueEffect: 'Final Dmg +5%', purpleEffect: 'Fire Core summon 8s', orange1Effect: 'DoT +20%', orange2Effect: '250% ATK + knockback + 5 Burning', newElement: null, addsStatus: 'Burning', keyStats: 'Final Dmg +5%, DoT +20%', provides: ['fire', 'burning-stacks', 'dot-boost', 'final-dmg', 'summon'], wants: [] },
      { skill: 'Infernal Bloom', name: 'Electric Eel', blueEffect: 'CD -2s', purpleEffect: 'Electric Eel companion 10s', orange1Effect: 'Final Dmg +5%', orange2Effect: '15s duration, max 3 summons', newElement: 'Lightning', addsStatus: null, keyStats: 'CD -2s, Final Dmg +5%', provides: ['lightning', 'cd-reduction', 'final-dmg', 'summon'], wants: [] },
      // Ultimate Skills
      { skill: 'Hail', name: 'Glacial', blueEffect: 'HoH +30%', purpleEffect: '+1s duration, 10% Imprison', orange1Effect: 'Add Dmg Chance +10%', orange2Effect: '5x per second instead of 2x', newElement: null, addsStatus: 'Imprison', keyStats: 'HoH +30%, Add Dmg Chance +10%', provides: ['ice', 'hoh', 'multi-hit', 'imprison', 'add-dmg', 'sustain', 'control'], wants: [] },
      { skill: 'Hail', name: 'Skyfire', blueEffect: 'CD -5s', purpleEffect: 'Meteor 200% ATK 8 Burning', orange1Effect: 'DoT +20%', orange2Effect: 'Burning area 80% ATK/s', newElement: 'Fire', addsStatus: 'Burning', keyStats: 'CD -5s, DoT +20%', provides: ['fire', 'burning-stacks', 'dot-boost', 'cd-reduction', 'aoe'], wants: [] },
      { skill: 'Hail', name: 'Meteor', blueEffect: 'Dmg +30%', purpleEffect: 'Electric meteors 300% ATK 3 Electrocution', orange1Effect: 'Crit Chance +5%', orange2Effect: '+1 meteor 350% ATK 5 Electrocution', newElement: 'Lightning', addsStatus: 'Electrocution', keyStats: 'Dmg +30%, Crit Chance +5%', provides: ['lightning', 'electrocution', 'stun', 'dmg-boost', 'crit-chance', 'burst'], wants: [] },
      { skill: 'Doppelganger', name: 'Ice Soul', blueEffect: 'Final Dmg‚Üì +5%', purpleEffect: 'Ice Clone 70% HP 12s', orange1Effect: 'Add Dmg +30%', orange2Effect: '50% HP ice shield + Freeze on break', newElement: 'Ice', addsStatus: 'Freeze', keyStats: 'Final Dmg‚Üì +5%, Add Dmg +30%', provides: ['ice', 'freeze', 'add-dmg', 'final-dmg-down', 'clone', 'sustain', 'control'], wants: [] },
      { skill: 'Doppelganger', name: 'Ember', blueEffect: 'Ele Dmg +5%', purpleEffect: 'Fire Clone 70% HP 12s', orange1Effect: 'CD -10s', orange2Effect: 'On death 800% ATK + 20 Burning', newElement: 'Fire', addsStatus: 'Burning', keyStats: 'Ele Dmg +5%, CD -10s', provides: ['fire', 'burning-stacks', 'ele-dmg', 'cd-reduction', 'clone', 'burst'], wants: [] },
      { skill: 'Doppelganger', name: 'Thunderbolt', blueEffect: 'MP Regen +5%', purpleEffect: 'Lightning Clone 70% HP 12s', orange1Effect: 'Final Dmg +5%', orange2Effect: '50% enhanced orb 100% ATK 5x + 3 Electrocution', newElement: 'Lightning', addsStatus: 'Electrocution', keyStats: 'MP Regen +5%, Final Dmg +5%', provides: ['lightning', 'electrocution', 'mp', 'final-dmg', 'clone'], wants: [] },
      { skill: 'Aether Form', name: 'Cryo', blueEffect: 'MP Regen +5%', purpleEffect: 'Ice form casts Ice Thorn', orange1Effect: 'Final Dmg‚Üì +5%', orange2Effect: '+15% Ele Dmg + Accuracy', newElement: 'Ice', addsStatus: null, keyStats: 'MP Regen +5%, Final Dmg‚Üì +5%', provides: ['ice', 'mp', 'final-dmg-down', 'ele-dmg', 'sustain'], wants: [] },
      { skill: 'Aether Form', name: 'Wildfire', blueEffect: 'DoT +20%', purpleEffect: 'Fire form casts Wildfire Spread', orange1Effect: 'Final Dmg +5%', orange2Effect: '+15% Ele Dmg + Accuracy', newElement: 'Fire', addsStatus: null, keyStats: 'DoT +20%, Final Dmg +5%', provides: ['fire', 'dot-boost', 'final-dmg', 'ele-dmg'], wants: [] },
      { skill: 'Aether Form', name: 'Thunder', blueEffect: 'Crit Chance +5%', purpleEffect: 'Lightning form casts Thunderstorm', orange1Effect: 'HoH +30%', orange2Effect: '+15% Ele Dmg + Accuracy', newElement: 'Lightning', addsStatus: null, keyStats: 'Crit Chance +5%, HoH +30%', provides: ['lightning', 'crit-chance', 'hoh', 'ele-dmg', 'sustain'], wants: [] },
    ];

    let PROFILE = {
      stats: { atk: 2730, def: 400, hp: 120000, crit: 4.6, critDmg: 0, addDmgChance: 0, thorn: 0, haste: 0, mpRegen: 0, cdReduction: 0, hoh: 0, dot: 0, eleDmg: 0, finalDmg: 0, evasion: 0 },
      zenith: { pool: 140, atk: 0, def: 0, hp: 0, crit: 0, addDmgChance: 0, thorn: 0, haste: 0, mpRegen: 0, cdReduction: 0, hoh: 0 },
      runeUnlocks: {},
      currentBuild: null
    };

    // All character stats - player enters what they see in game
    const STAT_CONFIG = [
      { key: 'atk', label: 'ATK', default: 2730, flat: true },
      { key: 'def', label: 'DEF', default: 400, flat: true },
      { key: 'hp', label: 'HP', default: 120000, flat: true },
      { key: 'crit', label: 'Crit %', default: 4.6 },
      { key: 'critDmg', label: 'Crit Dmg %', default: 0 },
      { key: 'addDmgChance', label: 'Add Dmg Chance %', default: 0 },
      { key: 'thorn', label: 'Thorn %', default: 0 },
      { key: 'haste', label: 'Haste %', default: 0 },
      { key: 'mpRegen', label: 'MP Regen %', default: 0 },
      { key: 'cdReduction', label: 'CD %', default: 0 },
      { key: 'hoh', label: 'HoH %', default: 0 },
      { key: 'dot', label: 'DoT %', default: 0 },
      { key: 'eleDmg', label: 'Ele Dmg %', default: 0 },
      { key: 'finalDmg', label: 'Final Dmg %', default: 0 },
      { key: 'evasion', label: 'Evasion %', default: 0 },
    ];

    // Zenith stats - point allocation system
    const ZENITH_CONFIG = [
      { key: 'atk', label: 'ATK', max: null },
      { key: 'def', label: 'DEF', max: null },
      { key: 'hp', label: 'HP', max: null },
      { key: 'crit', label: 'Crit %', max: 50 },
      { key: 'addDmgChance', label: 'Add Dmg %', max: 50 },
      { key: 'thorn', label: 'Thorn %', max: 50 },
      { key: 'haste', label: 'Haste %', max: 50 },
      { key: 'mpRegen', label: 'MP Regen %', max: 50 },
      { key: 'cdReduction', label: 'CD %', max: 50 },
      { key: 'hoh', label: 'HoH %', max: 50 },
    ];

    const currentBuild = { core: null, basic: null, basicControl: null, elemControl: null, ultimate: null, runes: {}, passives: [null, null, null] };
    const theoryBuild = { core: null, basic: null, basicControl: null, elemControl: null, ultimate: null, runes: {}, passives: [null, null, null] };
    let activeTab = 'current';

    // ============ STAT PARSING ============
    function parseRuneStats(effectText) {
      const stats = {
        critChance: 0, critDmg: 0, hoh: 0, dot: 0, finalDmg: 0, finalDmgDown: 0,
        eleDmg: 0, dmg: 0, addDmg: 0, addDmgChance: 0, haste: 0, cdReduction: 0,
        mpRegen: 0, shieldStrength: 0, evasion: 0, healingReceived: 0,
        // Conditional
        critVsShocked: 0, critVsElectrocuted: 0,
        // Burning stacks applied
        burningStacks: 0, vulnerableStacks: 0
      };

      if (!effectText) return stats;
      const text = effectText.toLowerCase();

      // Direct stat bonuses
      const patterns = [
        { regex: /crit chance \+(\d+)%/i, key: 'critChance' },
        { regex: /crit dmg \+(\d+)%/i, key: 'critDmg' },
        { regex: /crit \+(\d+)%/i, key: 'critChance' },
        { regex: /hoh \+(\d+)%/i, key: 'hoh' },
        { regex: /heal on hit \+(\d+)%/i, key: 'hoh' },
        { regex: /dot \+(\d+)%/i, key: 'dot' },
        { regex: /final dmg \+(\d+)%/i, key: 'finalDmg' },
        { regex: /final dmg‚Üì \+(\d+)%/i, key: 'finalDmgDown' },
        { regex: /ele dmg \+(\d+)%/i, key: 'eleDmg' },
        { regex: /elemental dmg \+(\d+)%/i, key: 'eleDmg' },
        { regex: /dmg \+(\d+)%/i, key: 'dmg' },
        { regex: /additional damage \+(\d+)%/i, key: 'addDmg' },
        { regex: /additional damage chance \+(\d+)%/i, key: 'addDmgChance' },
        { regex: /haste \+(\d+)%/i, key: 'haste' },
        { regex: /base cd -(\d+)s/i, key: 'cdReduction' },
        { regex: /mp regen \+(\d+)%/i, key: 'mpRegen' },
        { regex: /shield strength \+(\d+)%/i, key: 'shieldStrength' },
        { regex: /shield \+(\d+)%/i, key: 'shieldStrength' },
        { regex: /evasion \+(\d+)%/i, key: 'evasion' },
        { regex: /healing received \+(\d+)%/i, key: 'healingReceived' },
        { regex: /healing \+(\d+)%/i, key: 'healingReceived' },
      ];

      patterns.forEach(({ regex, key }) => {
        const match = effectText.match(regex);
        if (match) stats[key] += parseInt(match[1]);
      });

      // Conditional: Crit vs Shocked
      const critVsShocked = effectText.match(/\+(\d+)% crit vs shocked/i);
      if (critVsShocked) stats.critVsShocked = parseInt(critVsShocked[1]);

      // Burning stacks
      const burningMatch = effectText.match(/(\d+)\s*burning/i);
      if (burningMatch) stats.burningStacks = parseInt(burningMatch[1]);

      // Vulnerable stacks
      const vulnMatch = effectText.match(/(\d+)\s*vulnerable/i);
      if (vulnMatch) stats.vulnerableStacks = parseInt(vulnMatch[1]);

      return stats;
    }

    function getRuneStatsAtTier(rune, tierLevel) {
      const effects = [rune.blueEffect, rune.purpleEffect, rune.orange1Effect, rune.orange2Effect];
      const combined = {
        critChance: 0, critDmg: 0, hoh: 0, dot: 0, finalDmg: 0, finalDmgDown: 0,
        eleDmg: 0, dmg: 0, addDmg: 0, addDmgChance: 0, haste: 0, cdReduction: 0,
        mpRegen: 0, shieldStrength: 0, evasion: 0, healingReceived: 0,
        critVsShocked: 0, burningStacks: 0, vulnerableStacks: 0
      };

      for (let i = 0; i < tierLevel && i < effects.length; i++) {
        const parsed = parseRuneStats(effects[i]);
        Object.keys(combined).forEach(k => combined[k] += parsed[k]);
      }
      return combined;
    }

    function getBuildStats(build) {
      // Start with profile stats + zenith bonuses
      const totals = {
        atk: PROFILE.stats.atk + (PROFILE.zenith.atk || 0),
        def: PROFILE.stats.def + (PROFILE.zenith.def || 0),
        hp: PROFILE.stats.hp + (PROFILE.zenith.hp || 0),
        critChance: PROFILE.stats.crit + (PROFILE.zenith.crit || 0),
        critDmg: PROFILE.stats.critDmg,
        addDmgChance: PROFILE.stats.addDmgChance + (PROFILE.zenith.addDmgChance || 0),
        thorn: PROFILE.stats.thorn + (PROFILE.zenith.thorn || 0),
        haste: PROFILE.stats.haste + (PROFILE.zenith.haste || 0),
        mpRegen: PROFILE.stats.mpRegen + (PROFILE.zenith.mpRegen || 0),
        cdReduction: PROFILE.stats.cdReduction + (PROFILE.zenith.cdReduction || 0),
        hoh: PROFILE.stats.hoh + (PROFILE.zenith.hoh || 0),
        dot: PROFILE.stats.dot,
        eleDmg: PROFILE.stats.eleDmg,
        finalDmg: PROFILE.stats.finalDmg,
        evasion: PROFILE.stats.evasion,
        // Rune-only stats (no profile input)
        finalDmgDown: 0,
        dmg: 0,
        addDmg: 0,
        shieldStrength: 0,
        healingReceived: 0,
        critVsShocked: 0,
        burningStacks: 0,
        vulnerableStacks: 0
      };

      // Add bonuses from selected runes
      const skills = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate].filter(Boolean);
      skills.forEach(skill => {
        const runeName = build.runes[skill.name];
        if (runeName) {
          const rune = RUNES.find(r => r.skill === skill.name && r.name === runeName);
          if (rune) {
            const tierLevel = getRuneTierLevel(skill.name, runeName);
            const runeStats = getRuneStatsAtTier(rune, tierLevel);
            Object.keys(totals).forEach(k => { if (runeStats[k]) totals[k] += runeStats[k]; });
          }
        }
      });

      return totals;
    }

    function getAllStatuses(build) {
      const statuses = new Set();
      const skills = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate].filter(Boolean);
      
      skills.forEach(skill => {
        if (skill.status) statuses.add(skill.status);
        const runeName = build.runes[skill.name];
        if (runeName) {
          const rune = RUNES.find(r => r.skill === skill.name && r.name === runeName);
          if (rune?.addsStatus && getRuneTierLevel(skill.name, runeName) >= 2) {
            rune.addsStatus.split(',').forEach(s => statuses.add(s.trim()));
          }
        }
      });
      return Array.from(statuses);
    }

    // ============ BUILD FLAGS (Relationship-Based) ============

    function countBurningStackSources(build) {
      let sources = [];
      const skills = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate].filter(Boolean);
      
      skills.forEach(skill => {
        const runeName = build.runes[skill.name];
        if (runeName) {
          const rune = RUNES.find(r => r.skill === skill.name && r.name === runeName);
          const tier = getRuneTierLevel(skill.name, runeName);
          const effects = [rune?.blueEffect, rune?.purpleEffect, rune?.orange1Effect, rune?.orange2Effect];
          for (let i = 0; i < tier && i < effects.length; i++) {
            const effect = effects[i] || '';
            const match = effect.match(/(\d+)\s*burning/i);
            if (match && parseInt(match[1]) >= 3) {
              sources.push({ skill: skill.name, rune: runeName, stacks: parseInt(match[1]) });
            }
          }
        }
      });
      return sources;
    }

    function countSustainTools(build) {
      const tools = [];
      const skills = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate].filter(Boolean);
      const stats = getBuildStats(build);
      
      skills.forEach(skill => {
        if (skill.shield) tools.push(skill.name);
        if (skill.hpRecovery) tools.push(skill.name);
      });
      
      if (stats.hoh > 0) tools.push('HoH');
      if (stats.finalDmgDown > 0) tools.push('Final Dmg‚Üì');
      if (build.passives.some(p => p?.id === 'arcane_shield')) tools.push('Arcane Shield');
      if (build.passives.some(p => p?.id === 'life_rewind')) tools.push('Life Rewind');
      if (build.passives.some(p => p?.id === 'tumbler')) tools.push('Tumbler');
      
      return tools;
    }

    // ============ TAG SYSTEM ============
    function getBuildProvides(build) {
      const provides = new Set();
      const skills = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate].filter(Boolean);
      
      // Add skill provides + implicit provides from status/element
      skills.forEach(skill => {
        (skill.provides || []).forEach(tag => provides.add(tag));
        // Derive from status (Shock -> shock, Burning -> burning, etc.)
        if (skill.status) provides.add(skill.status.toLowerCase());
        // Derive from EFFECTIVE element (after rune conversion)
        const effectiveElem = getEffectiveElement(build, skill);
        if (effectiveElem) provides.add(effectiveElem.toLowerCase());
      });
      
      // Add rune provides (only if unlocked to tier 2+)
      skills.forEach(skill => {
        const runeName = build.runes[skill.name];
        if (runeName) {
          const rune = RUNES.find(r => r.skill === skill.name && r.name === runeName);
          if (rune && getRuneTierLevel(skill.name, runeName) >= 2) {
            (rune.provides || []).forEach(tag => provides.add(tag));
            // Also add status from rune
            if (rune.addsStatus) {
              rune.addsStatus.split(',').map(s => s.trim().toLowerCase()).forEach(s => provides.add(s));
            }
          }
        }
      });
      
      // Add passive provides
      build.passives.filter(Boolean).forEach(p => {
        (p.provides || []).forEach(tag => provides.add(tag));
      });
      
      // Derive additional tags from stats
      const stats = getBuildStats(build);
      if (stats.critChance >= 15) provides.add('crit-chance');
      if (stats.dot >= 10) provides.add('dot-boost');
      if (stats.haste >= 20) provides.add('haste');
      if (stats.hoh >= 15) provides.add('hoh');
      if (stats.finalDmgDown >= 5) provides.add('sustain');
      
      return provides;
    }

    function getUnmetWants(build) {
      const provides = getBuildProvides(build);
      const unmet = [];
      const skills = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate].filter(Boolean);
      
      // Check rune wants
      skills.forEach(skill => {
        const runeName = build.runes[skill.name];
        if (runeName) {
          const rune = RUNES.find(r => r.skill === skill.name && r.name === runeName);
          if (rune && getRuneTierLevel(skill.name, runeName) >= 2) {
            (rune.wants || []).forEach(want => {
              if (!provides.has(want)) {
                unmet.push({ source: `${skill.name} ‚Üí ${runeName}`, wants: want });
              }
            });
          }
        }
      });
      
      // Check passive wants
      build.passives.filter(Boolean).forEach(p => {
        (p.wants || []).forEach(want => {
          if (!provides.has(want)) {
            unmet.push({ source: p.name, wants: want });
          }
        });
      });
      
      return unmet;
    }

    function getMatchingRecommendations(build) {
      const provides = getBuildProvides(build);
      const recs = { skills: [], runes: [], passives: [] };
      
      // Find runes whose WANTS are satisfied by our PROVIDES
      RUNES.forEach(rune => {
        if (rune.wants && rune.wants.length > 0) {
          const satisfied = rune.wants.every(want => provides.has(want));
          if (satisfied) {
            // Check if not already selected
            const skill = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate]
              .filter(Boolean).find(s => s.name === rune.skill);
            if (!skill || build.runes[rune.skill] !== rune.name) {
              recs.runes.push({ 
                skill: rune.skill, 
                rune: rune.name, 
                reason: `You have: ${rune.wants.join(', ')}`,
                provides: rune.provides
              });
            }
          }
        }
      });
      
      // Find passives whose WANTS are satisfied
      PASSIVES.forEach(p => {
        if (p.wants && p.wants.length > 0) {
          const satisfied = p.wants.every(want => provides.has(want));
          if (satisfied && !build.passives.some(bp => bp?.id === p.id)) {
            recs.passives.push({ id: p.id, reason: `You have: ${p.wants.join(', ')}` });
          }
        }
      });
      
      // Find skills that would fill gaps (provide what runes want)
      const allWants = new Set();
      RUNES.forEach(rune => {
        const selected = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate]
          .filter(Boolean).find(s => s.name === rune.skill && build.runes[rune.skill] === rune.name);
        if (selected) {
          (rune.wants || []).forEach(w => { if (!provides.has(w)) allWants.add(w); });
        }
      });
      
      // Find skills that provide what we're missing
      Object.values(SKILLS).flat().forEach(skill => {
        const skillProvides = skill.provides || [];
        const matches = skillProvides.filter(p => allWants.has(p));
        if (matches.length > 0) {
          const isSelected = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate]
            .some(s => s?.id === skill.id);
          if (!isSelected) {
            recs.skills.push({ id: skill.id, reason: `Provides: ${matches.join(', ')}` });
          }
        }
      });
      
      return recs;
    }

    function getBuildFlags(build) {
      const flags = [];
      const stats = getBuildStats(build);
      const statuses = getAllStatuses(build);
      const passives = build.passives.filter(Boolean);
      const skills = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate].filter(Boolean);
      const provides = getBuildProvides(build);

      // === CRIT BALANCE (only if build has crit focus) ===
      const hasCritFocus = provides.has('crit-chance') || provides.has('crit-dmg') || stats.critChance >= 15;
      if (hasCritFocus) {
        if (stats.critDmg > 30 && stats.critChance < 10) {
          flags.push({ type: 'info', text: `Crit Dmg ${stats.critDmg}% but low Crit ${stats.critChance}%` });
        } else if (stats.critChance >= 15 && stats.critDmg >= 30) {
          flags.push({ type: 'good', text: `Crit: ${stats.critChance}% Chance, ${stats.critDmg}% Dmg` });
        }
      }

      // === DOT + BURNING ===
      const burningStackSources = countBurningStackSources(build);
      if (stats.dot > 0) {
        if (burningStackSources.length === 0 && !statuses.includes('Burning')) {
          flags.push({ type: 'bad', text: `DoT +${stats.dot}%: no Burning` });
        } else if (burningStackSources.length > 0) {
          const totalStacks = burningStackSources.reduce((sum, s) => sum + s.stacks, 0);
          flags.push({ type: 'good', text: `DoT +${stats.dot}%: ${totalStacks}+ Burning stacks` });
        }
      }

      // === FLOURISH + DEMON PACT + SUSTAIN ===
      const hasFlourish = passives.some(p => p.id === 'flourish');
      const hasDemonPact = passives.some(p => p.id === 'demon_pact');
      const sustainTools = countSustainTools(build);

      if (hasFlourish && hasDemonPact) {
        flags.push({ type: 'info', text: `Flourish + Demon Pact: ${sustainTools.length} sustain` });
      } else if (hasFlourish) {
        if (sustainTools.length >= 2) {
          flags.push({ type: 'good', text: `Flourish: ${sustainTools.join(', ')}` });
        } else if (sustainTools.length === 1) {
          flags.push({ type: 'info', text: `Flourish: ${sustainTools.join(', ')}` });
        } else {
          flags.push({ type: 'info', text: `Flourish: no sustain tools` });
        }
      }

      if (hasDemonPact && !hasFlourish) {
        const type = sustainTools.length >= 3 ? 'good' : sustainTools.length >= 1 ? 'info' : 'bad';
        flags.push({ type, text: `Demon Pact: ${sustainTools.length} sustain${sustainTools.length >= 3 ? ' ‚úì' : ''}` });
      }

      // === ELEMENTAL RESONANCE ===
      const hasElemRes = passives.some(p => p.id === 'elemental_resonance');
      if (hasElemRes) {
        if (statuses.length === 0) {
          flags.push({ type: 'bad', text: `Elemental Resonance: 0 statuses` });
        } else {
          flags.push({ type: statuses.length >= 2 ? 'good' : 'info', text: `Elemental Resonance: ${statuses.length} statuses (+${statuses.length * 5}%)` });
        }
      }

      // === CONJURATION ===
      const hasConjuration = passives.some(p => p.id === 'conjuration');
      if (hasConjuration) {
        const cdSkills = skills.filter(s => s.cd && s.cd > 0);
        flags.push({ type: cdSkills.length >= 2 ? 'good' : 'info', text: `Conjuration: ${cdSkills.length} CD skills` });
      }

      // === DOPPELGANGER ===
      if (build.ultimate?.id === 'doppelganger' && build.basic) {
        const basicRune = build.runes[build.basic.name];
        if (basicRune) {
          const rune = RUNES.find(r => r.skill === build.basic.name && r.name === basicRune);
          flags.push({ type: 'good', text: `Doppelganger: clones ${build.basic.name} + ${basicRune}` });
        } else {
          flags.push({ type: 'info', text: `Doppelganger: clones ${build.basic.name}` });
        }
      }

      // === VULNERABLE ===
      if (stats.vulnerableStacks >= 5) {
        flags.push({ type: 'good', text: `${stats.vulnerableStacks}+ Vulnerable stacks` });
      }

      // === UNMET WANTS (Tag System) ===
      const unmet = getUnmetWants(build);
      unmet.forEach(u => {
        flags.push({ type: 'bad', text: `${u.source}: needs ${u.wants}` });
      });

      // === SATISFIED WANTS (Tag System) ===
      const selectedSkills = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate].filter(Boolean);
      selectedSkills.forEach(skill => {
        const runeName = build.runes[skill.name];
        if (runeName) {
          const rune = RUNES.find(r => r.skill === skill.name && r.name === runeName);
          if (rune && rune.wants && rune.wants.length > 0 && getRuneTierLevel(skill.name, runeName) >= 2) {
            const satisfied = rune.wants.every(want => provides.has(want));
            if (satisfied) {
              flags.push({ type: 'good', text: `${runeName}: ${rune.wants.join(', ')} ‚úì` });
            }
          }
        }
      });

      return { flags, stats };
    }

    // ============ SMART RECOMMENDATIONS (Tag-Based) ============
    function getSmartRecommendations(build) {
      const recs = { basic: [], core: [], control: [], ultimate: [], passives: [], runes: [] };
      const provides = getBuildProvides(build);
      const tagRecs = getMatchingRecommendations(build);
      
      // Add rune recommendations from tag matching
      tagRecs.runes.forEach(r => {
        recs.runes.push({ skill: r.skill, rune: r.rune, reason: r.reason });
      });
      
      // Add passive recommendations from tag matching
      tagRecs.passives.forEach(p => {
        recs.passives.push(p.id);
      });
      
      // Add skill recommendations from tag matching (fill gaps)
      tagRecs.skills.forEach(s => {
        const skill = Object.values(SKILLS).flat().find(sk => sk.id === s.id);
        if (skill) {
          const row = Object.entries(SKILLS).find(([k, v]) => v.includes(skill))?.[0];
          if (row === 'basic') recs.basic.push(s.id);
          else if (row === 'core') recs.core.push(s.id);
          else if (row === 'basicControl' || row === 'elemControl') recs.control.push(s.id);
          else if (row === 'ultimate') recs.ultimate.push(s.id);
        }
      });
      
      // === RUNES THAT WANT WHAT YOU PROVIDE ===
      RUNES.forEach(rune => {
        if (rune.wants && rune.wants.length > 0) {
          const satisfied = rune.wants.every(want => provides.has(want));
          if (satisfied) {
            // Check not already selected or recommended
            const alreadyRecd = recs.runes.some(r => r.skill === rune.skill && r.rune === rune.name);
            const skill = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate]
              .filter(Boolean).find(s => s.name === rune.skill);
            const alreadySelected = skill && build.runes[rune.skill] === rune.name;
            
            if (!alreadyRecd && !alreadySelected) {
              recs.runes.push({ 
                skill: rune.skill, 
                rune: rune.name, 
                reason: `Wants: ${rune.wants.join(', ')} ‚úì`
              });
            }
          }
        }
      });
      
      // === SKILLS THAT PROVIDE WHAT RUNES WANT ===
      const unmet = getUnmetWants(build);
      const neededTags = [...new Set(unmet.map(u => u.wants))];
      
      Object.values(SKILLS).flat().forEach(skill => {
        const skillProvides = skill.provides || [];
        const matches = skillProvides.filter(p => neededTags.includes(p));
        if (matches.length > 0) {
          const isSelected = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate]
            .some(s => s?.id === skill.id);
          if (!isSelected) {
            const row = Object.entries(SKILLS).find(([k, v]) => v.includes(skill))?.[0];
            if (row === 'basic' && !recs.basic.includes(skill.id)) recs.basic.push(skill.id);
            else if (row === 'core' && !recs.core.includes(skill.id)) recs.core.push(skill.id);
            else if ((row === 'basicControl' || row === 'elemControl') && !recs.control.includes(skill.id)) recs.control.push(skill.id);
            else if (row === 'ultimate' && !recs.ultimate.includes(skill.id)) recs.ultimate.push(skill.id);
          }
        }
      });

      // Dedupe
      Object.keys(recs).forEach(k => {
        if (k === 'runes') {
          const seen = new Set();
          recs.runes = recs.runes.filter(r => {
            const key = `${r.skill}|${r.rune}`;
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
          });
        } else {
          recs[k] = [...new Set(recs[k])];
        }
      });
      
      return recs;
    }

    // ============ TABS ============
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
        activeTab = btn.dataset.tab;
        if (activeTab === 'current') renderCurrentBuild();
        if (activeTab === 'theorycraft') renderTheorycraft();
        if (activeTab === 'profile') renderProfile();
      });
    });

    // ============ PROFILE ============
    function loadProfile() {
      // Try current key first, then migrate from old versions
      let saved = localStorage.getItem('lootfiend-profile');
      if (!saved) saved = localStorage.getItem('lootfiend-profile-v3');
      if (!saved) saved = localStorage.getItem('lootfiend-profile-v2');
      
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          // Merge carefully to preserve all fields
          if (parsed.stats) PROFILE.stats = { ...PROFILE.stats, ...parsed.stats };
          if (parsed.zenith) PROFILE.zenith = { ...PROFILE.zenith, ...parsed.zenith };
          if (parsed.runeUnlocks) PROFILE.runeUnlocks = parsed.runeUnlocks;
          if (parsed.currentBuild) {
            PROFILE.currentBuild = parsed.currentBuild;
            Object.assign(currentBuild, parsed.currentBuild);
            restoreBuildReferences(currentBuild);
          }
          // Save to current key if migrated from old
          saveProfile();
        } catch (e) { console.error('Failed to load profile:', e); }
      }
    }

    function restoreBuildReferences(build) {
      if (build.core && typeof build.core === 'string') build.core = SKILLS.core.find(s => s.id === build.core) || null;
      ['basic', 'basicControl', 'elemControl', 'ultimate'].forEach(key => {
        if (build[key] && typeof build[key] === 'string') {
          const all = [...(SKILLS[key] || []), ...SKILLS.basicControl, ...SKILLS.elemControl, ...SKILLS.ultimate, ...SKILLS.basic];
          build[key] = all.find(s => s.id === build[key]) || null;
        }
      });
      build.passives = (build.passives || [null, null, null]).map(p => typeof p === 'string' ? PASSIVES.find(ps => ps.id === p) || null : p);
    }

    function saveProfile() {
      const buildToSave = {
        core: currentBuild.core?.id || null,
        basic: currentBuild.basic?.id || null,
        basicControl: currentBuild.basicControl?.id || null,
        elemControl: currentBuild.elemControl?.id || null,
        ultimate: currentBuild.ultimate?.id || null,
        runes: { ...currentBuild.runes },
        passives: currentBuild.passives.map(p => p?.id || null)
      };
      PROFILE.currentBuild = buildToSave;
      localStorage.setItem('lootfiend-profile', JSON.stringify(PROFILE));
    }

    function showSaveIndicator(id) {
      const el = document.getElementById(id);
      if (el) { el.classList.add('show'); setTimeout(() => el.classList.remove('show'), 1500); }
    }

    function renderProfile() {
      // Zenith section
      document.getElementById('zenith-pool').value = PROFILE.zenith.pool;
      document.getElementById('zenith-inputs').innerHTML = ZENITH_CONFIG.map(stat => `
        <div class="zenith-input-group">
          <div class="zenith-input-label">${stat.label}${stat.max ? ` <span style="opacity:0.5">(max ${stat.max})</span>` : ''}</div>
          <input type="number" class="zenith-input" value="${PROFILE.zenith[stat.key] || 0}" onchange="updateZenith('${stat.key}', this.value, ${stat.max || 'null'})" min="0"${stat.max ? ` max="${stat.max}"` : ''}>
        </div>
      `).join('');
      updateZenithRemaining();

      // Stats section
      document.getElementById('stats-inputs').innerHTML = STAT_CONFIG.map(stat => `
        <div class="stat-input-group">
          <div class="stat-input-label">${stat.label}</div>
          <input type="number" class="stat-input" value="${PROFILE.stats[stat.key]}" onchange="updateStat('${stat.key}', this.value)">
        </div>
      `).join('');
      renderRuneUnlocks();
    }

    function updateZenithPool(value) {
      PROFILE.zenith.pool = parseInt(value) || 0;
      updateZenithRemaining();
      saveProfile();
      showSaveIndicator('zenith-saved');
    }

    function updateZenith(key, value, max) {
      let val = parseInt(value) || 0;
      if (max && val > max) val = max;
      if (val < 0) val = 0;
      PROFILE.zenith[key] = val;
      updateZenithRemaining();
      saveProfile();
      showSaveIndicator('zenith-saved');
      renderProfile();
    }

    function updateZenithRemaining() {
      const spent = ZENITH_CONFIG.reduce((sum, s) => sum + (PROFILE.zenith[s.key] || 0), 0);
      const remaining = PROFILE.zenith.pool - spent;
      const el = document.getElementById('zenith-remaining');
      el.textContent = `${remaining} remaining`;
      el.className = 'zenith-remaining ' + (remaining < 0 ? 'over' : remaining === 0 ? 'ok' : '');
    }

    function renderRuneUnlocks() {
      const container = document.getElementById('rune-unlocks');
      const skillRunes = {};
      RUNES.forEach(r => { if (!skillRunes[r.skill]) skillRunes[r.skill] = []; skillRunes[r.skill].push(r); });
      const skillRows = {};
      Object.entries(SKILLS).forEach(([row, skills]) => skills.forEach(s => skillRows[s.name] = row));
      const rowLabels = { basic: 'Basic', core: 'Core', basicControl: 'Ctrl', elemControl: 'Elem', ultimate: 'Ult' };

      let html = '';
      Object.entries(skillRunes).forEach(([skillName, runes]) => {
        const row = skillRows[skillName];
        html += `<div class="rune-skill-section"><div class="rune-skill-name">${skillName} <span class="skill-row-label">${rowLabels[row] || ''}</span></div><div class="rune-row">${runes.map(r => renderRuneCard(skillName, r)).join('')}</div></div>`;
      });
      container.innerHTML = html || '<div class="none-text">Load data first</div>';
    }

    function renderRuneCard(skillName, rune) {
      const key = `${skillName}|${rune.name}`;
      const tierLevel = PROFILE.runeUnlocks[key] ?? 1;
      if (rune.blueEffect === 'Locked') return `<div class="rune-card" style="opacity:0.4;"><div class="rune-card-name">${rune.name}</div><div style="font-size:9px;color:rgba(200,200,210,0.3);">LOCKED</div></div>`;

      const tiers = [
        { key: 'blue', label: 'BLU', effect: rune.blueEffect },
        { key: 'purple', label: 'PUR', effect: rune.purpleEffect },
        { key: 'yellow', label: 'YEL', effect: rune.orange1Effect },
        { key: 'orange', label: 'ORA', effect: rune.orange2Effect },
      ];

      return `
        <div class="rune-card">
          <div class="rune-card-header"><span class="rune-card-name">${rune.name}</span>${rune.newElement ? `<span class="element-tag ${rune.newElement.toLowerCase()}">${rune.newElement}</span>` : ''}</div>
          <div class="tier-pill">${tiers.map((t, i) => `<button class="tier-pill-btn ${t.key} ${tierLevel >= i + 1 ? 'active' : ''}" onclick="setRuneTier('${key}', ${i + 1})">${t.label}</button>`).join('')}</div>
          <div class="rune-effects">${tiers.map((t, i) => `<div class="rune-effect-row ${tierLevel >= i + 1 ? '' : 'locked'}"><span class="tier-badge ${t.key}">${t.label}</span><span class="rune-effect-text">${t.effect}</span></div>`).join('')}</div>
        </div>
      `;
    }

    function setRuneTier(key, level) {
      const current = PROFILE.runeUnlocks[key] ?? 1;
      PROFILE.runeUnlocks[key] = (current === level && level > 0) ? level - 1 : level;
      saveProfile();
      showSaveIndicator('runes-saved');
      renderRuneUnlocks();
    }

    function updateStat(key, value) {
      PROFILE.stats[key] = parseFloat(value) || 0;
      saveProfile();
      showSaveIndicator('stats-saved');
    }

    function resetProfile() {
      if (confirm('Reset all?')) {
        PROFILE = { stats: {}, zenith: { pool: 140 }, runeUnlocks: {}, currentBuild: null };
        STAT_CONFIG.forEach(s => PROFILE.stats[s.key] = s.default);
        ZENITH_CONFIG.forEach(s => PROFILE.zenith[s.key] = 0);
        Object.keys(currentBuild).forEach(k => currentBuild[k] = k === 'passives' ? [null, null, null] : (k === 'runes' ? {} : null));
        // Clear all versions of localStorage
        localStorage.removeItem('lootfiend-profile');
        localStorage.removeItem('lootfiend-profile-v2');
        localStorage.removeItem('lootfiend-profile-v3');
        saveProfile();
        renderProfile();
      }
    }

    async function loadStatsFromSheet() {
      const sheetId = localStorage.getItem('lootfiend-sheet-id');
      if (!sheetId) { alert('Set Sheet ID first'); return; }
      try {
        const res = await fetch(`https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=CharacterStats`);
        if (!res.ok) throw new Error('Failed');
        const data = parseCSV(await res.text());
        const map = { 'ATK': 'atk', 'DEF': 'def', 'HP': 'hp', 'Crit': 'crit', 'Crit Dmg': 'critDmg', 'Add Dmg Chance': 'addDmgChance', 'Thorn': 'thorn', 'Haste': 'haste', 'MP Regen': 'mpRegen', 'CD': 'cdReduction', 'HoH': 'hoh', 'Heal on Hit': 'hoh', 'DoT': 'dot', 'Ele Dmg': 'eleDmg', 'Elemental Dmg': 'eleDmg', 'Final Dmg': 'finalDmg', 'Evasion': 'evasion' };
        data.forEach(row => { const k = map[row['Stat']]; if (k) PROFILE.stats[k] = parseFloat(row['Value']) || 0; });
        saveProfile();
        renderProfile();
        showSaveIndicator('stats-saved');
      } catch (e) { alert('Error: ' + e.message); }
    }

    // ============ DATA ============
    function showStatus(msg, type) {
      const el = document.getElementById('config-status');
      el.className = 'config-status ' + type;
      el.textContent = msg;
    }

    async function loadFromSheets() {
      const sheetId = document.getElementById('sheet-id').value.trim();
      if (!sheetId) { showStatus('Enter Sheet ID', 'error'); return; }
      localStorage.setItem('lootfiend-sheet-id', sheetId);
      showStatus('Loading...', 'loading');
      try {
        const [skillsRes, passivesRes, runesRes] = await Promise.all([
          fetch(`https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=Skills`),
          fetch(`https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=Passives`),
          fetch(`https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=Runes`),
        ]);
        if (skillsRes.ok) parseSkillsCSV(await skillsRes.text());
        if (passivesRes.ok) parsePassivesCSV(await passivesRes.text());
        if (runesRes.ok) parseRunesCSV(await runesRes.text());
        restoreBuildReferences(currentBuild);
        showStatus('‚úì Loaded!', 'success');
        renderCurrentBuild();
      } catch (e) { showStatus('Error: ' + e.message, 'error'); }
    }

    function parseCSV(text) {
      const lines = text.split('\n');
      const headers = parseCSVLine(lines[0]);
      return lines.slice(1).filter(l => l.trim()).map(line => {
        const values = parseCSVLine(line);
        const row = {};
        headers.forEach((h, i) => row[h.trim()] = values[i]?.trim() || '');
        return row;
      });
    }

    function parseCSVLine(line) {
      const result = []; let current = ''; let inQuotes = false;
      for (const char of line) {
        if (char === '"') inQuotes = !inQuotes;
        else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
        else current += char;
      }
      result.push(current);
      return result;
    }

    function parseSkillsCSV(text) {
      const data = parseCSV(text);
      SKILLS = { basic: [], core: [], basicControl: [], elemControl: [], ultimate: [] };
      const rowMap = { 'Basic': 'basic', 'Core': 'core', 'Basic Control': 'basicControl', 'Elemental Control': 'elemControl', 'Ultimate': 'ultimate' };
      data.forEach(row => {
        const rowType = rowMap[row['Row']];
        if (rowType) {
          // Build provides from explicit column or derive from element/status
          let provides = [];
          if (row['Provides']) {
            provides = row['Provides'].split(';').map(s => s.trim()).filter(Boolean);
          } else {
            // Derive from element and status
            if (row['Element']) provides.push(row['Element'].toLowerCase());
            if (row['Status Effect']) provides.push(row['Status Effect'].toLowerCase());
          }
          
          SKILLS[rowType].push({
            id: row['Skill Name'].toLowerCase().replace(/\s+/g, '_'),
            name: row['Skill Name'],
            element: row['Element'] || null,
            atk: parseFloat(row['ATK%']) || 0,
            status: row['Status Effect'] || null,
            mpCost: parseInt(row['MP Cost']) || 0,
            cd: parseInt(row['CD']) || 0,
            shield: parseFloat(row['Shield %']) || 0,
            hpRecovery: parseFloat(row['HP Recovery %']) || 0,
            desc: row['Special'] || `${row['ATK%'] || 0}% ATK`,
            hitRate: row['Hit Rate'] || 'medium',
            provides: provides,
          });
        }
      });
    }

    function parsePassivesCSV(text) {
      PASSIVES = parseCSV(text).map(row => ({
        id: row['Passive Name'].toLowerCase().replace(/\s+/g, '_'),
        name: row['Passive Name'],
        desc: row['Description'],
        downside: row['Downside'] === 'TRUE',
        archetype: row['Archetype'] || 'utility',
        provides: (row['Provides'] || '').split(';').map(s => s.trim()).filter(Boolean),
        wants: (row['Wants'] || '').split(';').map(s => s.trim()).filter(Boolean),
      }));
    }

    function parseRunesCSV(text) {
      RUNES = parseCSV(text).map(row => ({
        skill: row['Skill'],
        name: row['Rune Name'],
        blueEffect: row['Blue Effect'],
        purpleEffect: row['Purple Effect'],
        orange1Effect: row['Orange1 Effect'],
        orange2Effect: row['Orange2 Effect'],
        newElement: row['New Element'] || null,
        addsStatus: row['Adds Status'] || null,
        keyStats: row['Key Stats'] || '',
        provides: (row['Provides'] || '').split(';').map(s => s.trim()).filter(Boolean),
        wants: (row['Wants'] || '').split(';').map(s => s.trim()).filter(Boolean),
      }));
    }

    // ============ BUILD HELPERS ============
    function getRuneTierLevel(skill, rune) { return PROFILE.runeUnlocks[`${skill}|${rune}`] ?? 1; }
    function getRunesForSkill(name) { return RUNES.filter(r => r.skill === name && r.blueEffect !== 'Locked' && getRuneTierLevel(name, r.name) >= 1); }
    function getSelectedRune(build, skill) { const name = build.runes[skill]; return name ? RUNES.find(r => r.skill === skill && r.name === name) : null; }

    function getEffectiveElement(build, skill) {
      if (!skill) return null;
      const rune = getSelectedRune(build, skill.name);
      if (!rune) return skill.element;
      return (rune.newElement && getRuneTierLevel(skill.name, rune.name) >= 2) ? rune.newElement : skill.element;
    }

    function calcDamage(skill) {
      if (!skill?.atk) return 0;
      return Math.round(PROFILE.stats.atk * (skill.atk / 100) * (1 + PROFILE.stats.finalDmgUp / 100));
    }

    // ============ IDENTITY GROUPING ============
    function getAllRuneCombos() {
      const combos = [];
      const rowMap = {
        basic: 'Basic',
        core: 'Core', 
        basicControl: 'Ctrl',
        elemControl: 'Elem',
        ultimate: 'Ult'
      };
      
      Object.entries(SKILLS).forEach(([rowKey, skills]) => {
        skills.forEach(skill => {
          const runes = getRunesForSkill(skill.name);
          if (runes.length === 0) {
            // Skill with no runes
            combos.push({
              skill,
              rune: null,
              row: rowKey,
              rowLabel: rowMap[rowKey],
              identity: getComboIdentity(skill, null),
              provides: skill.provides || []
            });
          } else {
            runes.forEach(rune => {
              combos.push({
                skill,
                rune,
                row: rowKey,
                rowLabel: rowMap[rowKey],
                identity: getComboIdentity(skill, rune),
                provides: [...(skill.provides || []), ...(rune.provides || [])]
              });
            });
          }
        });
      });
      return combos;
    }

    function getComboIdentity(skill, rune) {
      const tags = new Set();
      
      // From skill
      if (skill.provides) skill.provides.forEach(t => tags.add(t));
      if (skill.element) tags.add(skill.element.toLowerCase());
      if (skill.status) tags.add(skill.status.toLowerCase());
      
      // From rune (if tier 2+)
      if (rune) {
        const tier = getRuneTierLevel(skill.name, rune.name);
        if (tier >= 2 && rune.provides) rune.provides.forEach(t => tags.add(t));
        if (tier >= 2 && rune.newElement) tags.add(rune.newElement.toLowerCase());
        if (tier >= 2 && rune.addsStatus) {
          rune.addsStatus.split(',').forEach(s => tags.add(s.trim().toLowerCase()));
        }
      }
      
      // Determine primary identity
      const hasDoT = tags.has('dot-boost') || tags.has('burning-stacks') || tags.has('burning');
      const hasCrit = tags.has('crit-chance') || tags.has('crit-dmg');
      const hasSustain = tags.has('sustain') || tags.has('shield') || tags.has('hoh') || tags.has('heal-boost');
      const hasControl = tags.has('control') || tags.has('imprison') || tags.has('freeze') || tags.has('stun') || tags.has('vulnerable');
      const hasBurst = tags.has('burst') || tags.has('dmg-boost') || tags.has('final-dmg');
      
      if (hasDoT) return 'dot';
      if (hasCrit) return 'crit';
      if (hasControl) return 'control';
      if (hasSustain) return 'sustain';
      if (hasBurst) return 'burst';
      return 'utility';
    }

    function groupCombosByIdentity(combos) {
      const groups = {
        dot: { name: 'DoT / Burning', icon: 'üî•', combos: [] },
        crit: { name: 'Crit', icon: '‚ö°', combos: [] },
        control: { name: 'Control', icon: 'üßä', combos: [] },
        sustain: { name: 'Sustain', icon: 'üíö', combos: [] },
        burst: { name: 'Burst / Damage', icon: 'üí•', combos: [] },
        utility: { name: 'Utility', icon: '‚öôÔ∏è', combos: [] }
      };
      
      combos.forEach(combo => {
        if (groups[combo.identity]) {
          groups[combo.identity].combos.push(combo);
        } else {
          groups.utility.combos.push(combo);
        }
      });
      
      return groups;
    }

    // ============ RENDER ============
    function renderBuilder(build, containerId, analysisId, mode) {
      const container = document.getElementById(containerId);
      const recs = getSmartRecommendations(build);
      const combos = getAllRuneCombos();
      const groups = groupCombosByIdentity(combos);
      
      // Track which rows are filled
      const filledRows = {};
      if (build.core) filledRows.core = build.core.id;
      if (build.basic) filledRows.basic = build.basic.id;
      if (build.basicControl) filledRows.basicControl = build.basicControl.id;
      if (build.elemControl) filledRows.elemControl = build.elemControl.id;
      if (build.ultimate) filledRows.ultimate = build.ultimate.id;
      
      let html = `<div class="identity-view">`;
      
      Object.entries(groups).forEach(([identity, group]) => {
        if (group.combos.length === 0) return;
        
        html += `<div class="identity-group">
          <div class="identity-group-header">
            <span class="identity-group-icon">${group.icon}</span>
            <span class="identity-group-name ${identity}">${group.name}</span>
          </div>
          <div class="identity-cards">`;
        
        group.combos.forEach(combo => {
          const isSelected = combo.rune 
            ? (build[combo.row]?.id === combo.skill.id && build.runes[combo.skill.name] === combo.rune.name)
            : (build[combo.row]?.id === combo.skill.id && !build.runes[combo.skill.name]);
          
          const rowTaken = filledRows[combo.row] && filledRows[combo.row] !== combo.skill.id;
          const sameSkillDiffRune = build[combo.row]?.id === combo.skill.id && combo.rune && build.runes[combo.skill.name] !== combo.rune.name;
          
          // Check if recommended
          const isRec = combo.rune 
            ? recs.runes.some(r => r.skill === combo.skill.name && r.rune === combo.rune.name)
            : false;
          
          const displayName = combo.rune ? combo.rune.name : combo.skill.name;
          const skillName = combo.rune ? `(${combo.skill.name})` : '';
          
          // Get element for coloring
          let element = combo.skill.element?.toLowerCase() || '';
          if (combo.rune?.newElement && getRuneTierLevel(combo.skill.name, combo.rune.name) >= 2) {
            element = combo.rune.newElement.toLowerCase();
          }
          
          // Key tags to show
          const keyTags = [];
          if (element) keyTags.push({ type: element, text: element.charAt(0).toUpperCase() + element.slice(1) });
          if (combo.rune?.addsStatus) {
            combo.rune.addsStatus.split(',').slice(0, 2).forEach(s => {
              keyTags.push({ type: 'status', text: s.trim() });
            });
          }
          if (combo.rune?.keyStats) {
            const statMatch = combo.rune.keyStats.match(/([A-Za-z\s‚Üì‚Üë]+)\s*\+?\d+%?/);
            if (statMatch) keyTags.push({ type: 'stat', text: statMatch[1].trim().substring(0, 12) });
          }
          
          html += `<div class="identity-card ${isSelected ? 'selected' : ''} ${rowTaken && !sameSkillDiffRune ? 'row-taken' : ''} ${isRec && !isSelected ? 'recommended' : ''}" 
                       onclick="${mode}SelectCombo('${combo.row}', '${combo.skill.id}', ${combo.rune ? `'${combo.rune.name}'` : 'null'})">
            <div class="identity-card-main">
              <span class="identity-card-rune">${displayName}</span>
              <span class="identity-card-skill">${skillName}</span>
              <span class="identity-card-row">${combo.rowLabel}</span>
            </div>
            <div class="identity-card-tags">
              ${keyTags.slice(0, 3).map(t => `<span class="identity-card-tag ${t.type}">${t.text}</span>`).join('')}
            </div>
          </div>`;
        });
        
        html += `</div></div>`;
      });
      
      html += `</div>`;
      
      // Passives section
      html += `<div class="passives-section"><div class="passives-title">PASSIVES (3)</div><div class="passives-grid">`;
      PASSIVES.forEach(p => {
        const isSelected = build.passives.some(bp => bp?.id === p.id);
        const rec = recs.passives.includes(p.id);
        html += `<div class="passive-card ${isSelected ? (p.downside ? 'selected-danger' : 'selected') : ''} ${rec && !isSelected ? 'recommended' : ''}" onclick="${mode}SelectPassive('${p.id}')">
          <div class="passive-name">${p.name}</div>
          <div class="passive-desc">${p.desc}</div>
        </div>`;
      });
      html += `</div></div>`;

      container.innerHTML = html;
      renderAnalysis(build, analysisId, mode);
    }

    // Selection handler for identity view
    function currentSelectCombo(row, skillId, runeName) {
      const skill = Object.values(SKILLS).flat().find(s => s.id === skillId);
      if (!skill) return;
      
      currentBuild[row] = skill;
      if (runeName) {
        currentBuild.runes[skill.name] = runeName;
      } else {
        delete currentBuild.runes[skill.name];
      }
      
      saveProfile();
      renderCurrentBuild();
    }

    function theorySelectCombo(row, skillId, runeName) {
      const skill = Object.values(SKILLS).flat().find(s => s.id === skillId);
      if (!skill) return;
      
      theoryBuild[row] = skill;
      if (runeName) {
        theoryBuild.runes[skill.name] = runeName;
      } else {
        delete theoryBuild.runes[skill.name];
      }
      
      renderTheorycraft();
    }

    function renderAnalysis(build, containerId, mode) {
      const container = document.getElementById(containerId);
      const { flags, stats } = getBuildFlags(build);
      const statuses = getAllStatuses(build);
      const skills = [build.core, build.basic, build.basicControl, build.elemControl, build.ultimate].filter(Boolean);
      const passives = build.passives.filter(Boolean);
      const provides = getBuildProvides(build);
      const unmet = getUnmetWants(build);

      let html = `<div class="analysis-title">BUILD ANALYSIS</div>`;

      // Build Identity + Coherence
      if (skills.length > 0) {
        const providesArr = [...provides];
        
        // Count elements
        const elements = providesArr.filter(t => ['ice', 'fire', 'lightning'].includes(t));
        const hasDoT = provides.has('dot-boost') || provides.has('burning-stacks') || provides.has('burning');
        const hasCrit = provides.has('crit-chance') || provides.has('crit-dmg');
        const hasSustain = provides.has('sustain') || provides.has('shield') || provides.has('hoh');
        const hasControl = provides.has('control') || provides.has('imprison') || provides.has('freeze') || provides.has('stun');
        const hasClone = provides.has('clone');
        const hasAoE = provides.has('aoe') || provides.has('multi-hit');
        
        // Build identity string
        const identity = [];
        if (elements.length === 1) identity.push(elements[0].charAt(0).toUpperCase() + elements[0].slice(1));
        else if (elements.length > 1) identity.push('Hybrid');
        else identity.push('Neutral');
        
        if (hasDoT) identity.push('DoT');
        if (hasCrit) identity.push('Crit');
        if (hasControl) identity.push('Control');
        if (hasClone) identity.push('Clone');
        if (hasAoE && !hasDoT && !hasCrit) identity.push('AoE');
        if (hasSustain) identity.push('Sustain');
        
        // Coherence: how many wants are satisfied?
        const totalWants = unmet.length + flags.filter(f => f.type === 'good' && f.text.includes('‚úì')).length;
        const satisfiedWants = flags.filter(f => f.type === 'good' && f.text.includes('‚úì')).length;
        const coherence = totalWants > 0 ? Math.round((satisfiedWants / totalWants) * 100) : 100;
        const coherenceClass = unmet.length === 0 ? 'high' : unmet.length <= 1 ? 'medium' : 'low';
        
        let coherenceHtml = '';
        if (unmet.length === 0 && skills.length >= 3) {
          coherenceHtml = '<div class="coherence-indicator high">‚úì Synergies aligned</div>';
        } else if (unmet.length > 0) {
          coherenceHtml = `<div class="coherence-indicator low">${unmet.length} missing synergy${unmet.length > 1 ? 's' : ''}</div>`;
        }
        
        html += `<div class="build-identity">
          <div class="identity-main"><span class="identity-label">BUILD:</span> <span class="identity-tags">${identity.slice(0, 4).join(' / ')}</span></div>
          ${coherenceHtml}
        </div>`;
      }

      // Build summary
      html += `<div class="build-summary">`;
      [{ l: 'CORE', k: 'core' }, { l: 'BASIC', k: 'basic' }, { l: 'CTRL', k: 'basicControl' }, { l: 'ELEM', k: 'elemControl' }, { l: 'ULT', k: 'ultimate' }].forEach(({ l, k }) => {
        const skill = build[k];
        if (skill) {
          const rune = getSelectedRune(build, skill.name);
          html += `<div class="build-item"><span class="build-item-label">${l}</span><span class="build-item-skill">${skill.name}</span>${rune ? `<span class="build-item-rune">${rune.name}</span>` : ''}</div>`;
        }
      });
      if (passives.length) html += `<div class="build-item"><span class="build-item-label">PASSIVES</span><span style="color:#86efac;font-size:9px;">${passives.map(p => p.name).join(', ')}</span></div>`;
      html += `</div>`;

      // Status
      html += `<div class="status-section"><div class="section-label">STATUS EFFECTS</div><div class="status-badges">`;
      html += statuses.length ? statuses.map(s => `<span class="status-badge ${s.toLowerCase().replace(/\s+/g, '')}">${s}</span>`).join('') : '<span class="none-text">None</span>';
      html += `</div></div>`;

      // Flags
      if (flags.length) {
        html += `<div class="section-label">BUILD FLAGS</div>`;
        const icons = { good: '‚ñ≤', bad: '‚ñº', info: 'üí°' };
        flags.forEach(f => {
          html += `<div class="flag-item ${f.type}"><span class="flag-icon">${icons[f.type]}</span><span>${f.text}</span></div>`;
        });
      }

      // Stat totals (Profile + Rune bonuses)
      html += `<div class="stat-totals"><div class="stat-totals-title">TOTAL STATS</div><div class="stat-totals-grid">`;
      const statDisplay = [
        { key: 'critChance', label: 'Crit', suffix: '%' },
        { key: 'critDmg', label: 'Crit Dmg', suffix: '%' },
        { key: 'addDmgChance', label: 'Add Dmg', suffix: '%' },
        { key: 'hoh', label: 'HoH', suffix: '%' },
        { key: 'dot', label: 'DoT', suffix: '%' },
        { key: 'eleDmg', label: 'Ele Dmg', suffix: '%' },
        { key: 'dmg', label: 'Dmg', suffix: '%' },
        { key: 'finalDmg', label: 'Final Dmg', suffix: '%' },
        { key: 'finalDmgDown', label: 'Final Dmg‚Üì', suffix: '%' },
        { key: 'haste', label: 'Haste', suffix: '%' },
        { key: 'cdReduction', label: 'CD', suffix: '%' },
        { key: 'mpRegen', label: 'MP Regen', suffix: '%' },
        { key: 'evasion', label: 'Evasion', suffix: '%' },
      ];
      statDisplay.forEach(({ key, label, suffix }) => {
        const val = stats[key] || 0;
        if (val > 0) html += `<div class="stat-row"><span class="stat-row-label">${label}</span><span class="stat-row-value">${val}${suffix}</span></div>`;
      });
      html += `</div></div>`;

      // Damage
      let totalDmg = skills.reduce((sum, s) => sum + calcDamage(s), 0);
      let mult = 1 + (stats.dmg / 100);
      if (passives.some(p => p.id === 'flourish')) mult += 0.15;
      if (passives.some(p => p.id === 'demon_pact')) mult += 0.30;
      if (passives.some(p => p.id === 'elemental_resonance')) mult += statuses.length * 0.05;
      totalDmg = Math.round(totalDmg * mult);

      html += `<div class="damage-calc"><div class="damage-calc-title">TOTAL DAMAGE</div><div class="damage-calc-value">${totalDmg.toLocaleString()}</div><div class="damage-calc-breakdown">√ó${mult.toFixed(2)} mult</div>`;
      if (mode === 'theory') {
        const currentFlags = getBuildFlags(currentBuild);
        const currentSkills = [currentBuild.core, currentBuild.basic, currentBuild.basicControl, currentBuild.elemControl, currentBuild.ultimate].filter(Boolean);
        let currentDmg = currentSkills.reduce((sum, s) => sum + calcDamage(s), 0);
        let currentMult = 1 + (currentFlags.stats.dmg / 100);
        if (currentBuild.passives.some(p => p?.id === 'flourish')) currentMult += 0.15;
        if (currentBuild.passives.some(p => p?.id === 'demon_pact')) currentMult += 0.30;
        if (currentBuild.passives.some(p => p?.id === 'elemental_resonance')) currentMult += getAllStatuses(currentBuild).length * 0.05;
        currentDmg = Math.round(currentDmg * currentMult);
        const diff = totalDmg - currentDmg;
        if (diff > 0) html += `<div class="comparison-indicator better">‚ñ≤ ${diff.toLocaleString()} vs current</div>`;
        else if (diff < 0) html += `<div class="comparison-indicator worse">‚ñº ${Math.abs(diff).toLocaleString()} vs current</div>`;
        else html += `<div class="comparison-indicator same">= same</div>`;
      }
      html += `</div>`;

      if (mode === 'current') {
        html += `<button class="save-build-btn" onclick="saveCurrentBuild()">üíæ SAVE BUILD</button><div class="saved-indicator" id="build-saved">‚úì Saved!</div>`;
        html += `<button class="reset-build-btn" onclick="resetCurrentBuild()">‚Ü∫ RESET</button>`;
      }
      if (mode === 'theory') {
        html += `<button class="reset-build-btn" onclick="resetTheoryBuild()">‚Ü∫ RESET</button>`;
      }

      container.innerHTML = html;
    }

    // ============ CURRENT BUILD ============
    function renderCurrentBuild() {
      renderBuilder(currentBuild, 'current-builder', 'current-analysis', 'current');
    }

    function currentSelectCore(id) {
      const skill = SKILLS.core.find(s => s.id === id);
      currentBuild.core = currentBuild.core?.id === id ? null : skill;
      if (skill) {
        const runes = getRunesForSkill(skill.name);
        if (runes.length && !currentBuild.runes[skill.name]) currentBuild.runes[skill.name] = runes[0].name;
      }
      renderCurrentBuild();
    }

    function currentSelectCoreRune(name) { if (currentBuild.core) currentBuild.runes[currentBuild.core.name] = name; renderCurrentBuild(); }

    function currentSelectSkill(row, id) {
      const skills = row === 'basicControl' || row === 'elemControl' ? [...SKILLS.basicControl, ...SKILLS.elemControl] : SKILLS[row];
      const skill = skills.find(s => s.id === id);
      if (row === 'basicControl' || row === 'elemControl') {
        const actualRow = SKILLS.basicControl.find(s => s.id === id) ? 'basicControl' : 'elemControl';
        currentBuild[actualRow] = currentBuild[actualRow]?.id === id ? null : skill;
      } else {
        currentBuild[row] = currentBuild[row]?.id === id ? null : skill;
      }
      if (skill) {
        const runes = getRunesForSkill(skill.name);
        if (runes.length && !currentBuild.runes[skill.name]) currentBuild.runes[skill.name] = runes[0].name;
      }
      renderCurrentBuild();
    }

    function currentSelectSkillRune(skill, rune) { currentBuild.runes[skill] = rune; renderCurrentBuild(); }

    function currentSelectPassive(id) {
      const passive = PASSIVES.find(p => p.id === id);
      const idx = currentBuild.passives.findIndex(p => p?.id === id);
      if (idx !== -1) currentBuild.passives[idx] = null;
      else {
        const empty = currentBuild.passives.findIndex(p => !p);
        if (empty !== -1) currentBuild.passives[empty] = passive;
        else currentBuild.passives[2] = passive;
      }
      renderCurrentBuild();
    }

    function saveCurrentBuild() {
      saveProfile();
      const el = document.getElementById('build-saved');
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), 1500);
    }

    function resetCurrentBuild() {
      currentBuild.core = null;
      currentBuild.basic = null;
      currentBuild.basicControl = null;
      currentBuild.elemControl = null;
      currentBuild.ultimate = null;
      currentBuild.runes = {};
      currentBuild.passives = [null, null, null];
      renderCurrentBuild();
    }

    function resetTheoryBuild() {
      theoryBuild.core = null;
      theoryBuild.basic = null;
      theoryBuild.basicControl = null;
      theoryBuild.elemControl = null;
      theoryBuild.ultimate = null;
      theoryBuild.runes = {};
      theoryBuild.passives = [null, null, null];
      renderTheorycraft();
    }

    // ============ THEORYCRAFT ============
    function renderTheorycraft() {
      renderCurrentSidebar();
      renderBuilder(theoryBuild, 'theory-builder', 'theory-analysis', 'theory');
    }

    function renderCurrentSidebar() {
      const container = document.getElementById('current-sidebar');
      const { stats } = getBuildFlags(currentBuild);
      const statuses = getAllStatuses(currentBuild);

      let html = `<div class="sidebar-title">üìå CURRENT BUILD</div>`;

      if (!currentBuild.core) {
        html += `<div class="no-build-msg">No build saved.<br>Set one in MY BUILD tab.</div>`;
      } else {
        [{ l: 'CORE', k: 'core' }, { l: 'BASIC', k: 'basic' }, { l: 'CTRL', k: 'basicControl' }, { l: 'ELEM', k: 'elemControl' }, { l: 'ULT', k: 'ultimate' }].forEach(({ l, k }) => {
          const skill = currentBuild[k];
          if (skill) {
            const rune = getSelectedRune(currentBuild, skill.name);
            html += `<div class="sidebar-build-item"><span class="sidebar-label">${l}</span><span class="sidebar-skill">${skill.name}</span>${rune ? `<span class="sidebar-rune">${rune.name}</span>` : ''}</div>`;
          }
        });

        const skills = [currentBuild.core, currentBuild.basic, currentBuild.basicControl, currentBuild.elemControl, currentBuild.ultimate].filter(Boolean);
        let dmg = skills.reduce((sum, s) => sum + calcDamage(s), 0);
        let mult = 1 + (stats.dmg / 100);
        if (currentBuild.passives.some(p => p?.id === 'flourish')) mult += 0.15;
        if (currentBuild.passives.some(p => p?.id === 'demon_pact')) mult += 0.30;
        if (currentBuild.passives.some(p => p?.id === 'elemental_resonance')) mult += statuses.length * 0.05;
        dmg = Math.round(dmg * mult);

        html += `<div class="sidebar-stats">`;
        html += `<div class="sidebar-stat"><span class="sidebar-stat-label">Damage</span><span class="sidebar-stat-value">${dmg.toLocaleString()}</span></div>`;
        html += `<div class="sidebar-stat"><span class="sidebar-stat-label">Statuses</span><span class="sidebar-stat-value">${statuses.length}</span></div>`;
        html += `</div>`;
      }

      container.innerHTML = html;
    }

    function theorySelectCore(id) {
      const skill = SKILLS.core.find(s => s.id === id);
      theoryBuild.core = theoryBuild.core?.id === id ? null : skill;
      if (skill) {
        const runes = getRunesForSkill(skill.name);
        if (runes.length && !theoryBuild.runes[skill.name]) theoryBuild.runes[skill.name] = runes[0].name;
      }
      renderTheorycraft();
    }

    function theorySelectCoreRune(name) { if (theoryBuild.core) theoryBuild.runes[theoryBuild.core.name] = name; renderTheorycraft(); }

    function theorySelectSkill(row, id) {
      const skills = row === 'basicControl' || row === 'elemControl' ? [...SKILLS.basicControl, ...SKILLS.elemControl] : SKILLS[row];
      const skill = skills.find(s => s.id === id);
      if (row === 'basicControl' || row === 'elemControl') {
        const actualRow = SKILLS.basicControl.find(s => s.id === id) ? 'basicControl' : 'elemControl';
        theoryBuild[actualRow] = theoryBuild[actualRow]?.id === id ? null : skill;
      } else {
        theoryBuild[row] = theoryBuild[row]?.id === id ? null : skill;
      }
      if (skill) {
        const runes = getRunesForSkill(skill.name);
        if (runes.length && !theoryBuild.runes[skill.name]) theoryBuild.runes[skill.name] = runes[0].name;
      }
      renderTheorycraft();
    }

    function theorySelectSkillRune(skill, rune) { theoryBuild.runes[skill] = rune; renderTheorycraft(); }

    function theorySelectPassive(id) {
      const passive = PASSIVES.find(p => p.id === id);
      const idx = theoryBuild.passives.findIndex(p => p?.id === id);
      if (idx !== -1) theoryBuild.passives[idx] = null;
      else {
        const empty = theoryBuild.passives.findIndex(p => !p);
        if (empty !== -1) theoryBuild.passives[empty] = passive;
        else theoryBuild.passives[2] = passive;
      }
      renderTheorycraft();
    }

    // ============ INIT ============
    loadProfile();
    const savedId = localStorage.getItem('lootfiend-sheet-id');
    if (savedId) {
      document.getElementById('sheet-id').value = savedId;
      loadFromSheets();
    } else {
      renderCurrentBuild();
    }
  </script>
</body>
</html>
